

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar2.jpg">
  <link rel="icon" href="/img/avatar2.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="幸福来敲门">
  <meta name="keywords" content="幸福来敲门,博客,技术贴,前端,后端,vue,hexo,html,css,小程序,uni-app,后台,移动端,建站,论坛,bootstrap,安卓,ios,技术前沿，技术博客,mui,ant-design,elementui,java,javaStrpict,sass,scss,less,React,Angular,jQuery">
  
    <meta name="description" content="javascripts知识点梳理5JS面向对象ECMAScript 有两种开发模式：1.函数式(过程化)，2.面向对象(OOP)。面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript 没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。 js（如果没有作特殊说明，本文中的js仅包含ES5以内的内容）本身是没有class类型的">
<meta property="og:type" content="article">
<meta property="og:title" content="javascripts知识点梳理5">
<meta property="og:url" content="http://luckyangyang.github.io/2019/04/02/javascripts%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%865/index.html">
<meta property="og:site_name" content="幸福来敲门">
<meta property="og:description" content="javascripts知识点梳理5JS面向对象ECMAScript 有两种开发模式：1.函数式(过程化)，2.面向对象(OOP)。面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript 没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。 js（如果没有作特殊说明，本文中的js仅包含ES5以内的内容）本身是没有class类型的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://luckyangyang.github.io/img/myimg4.jpg">
<meta property="article:published_time" content="2019-04-02T01:20:21.000Z">
<meta property="article:modified_time" content="2024-03-27T08:01:17.607Z">
<meta property="article:author" content="幸福来敲门">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://luckyangyang.github.io/img/myimg4.jpg">
  
  
  
  <title>javascripts知识点梳理5 - 幸福来敲门</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/font_gd7ak9jx13f/iconfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"luckyangyang.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>幸福来敲门</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/commonweal/" target="_self">
                <i class="iconfont icon-gongyi"></i>
                <span>公益</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/guestbook/" target="_self">
                <i class="iconfont icon-B-liuyan"></i>
                <span>留言</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="javascripts知识点梳理5"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-04-02 09:20" pubdate>
          2019年04月02日 09:20:21
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          3.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          26 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

    <script type="text/javascript" src="/js/love.js"></script>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">javascripts知识点梳理5</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="javascripts知识点梳理5"><a href="#javascripts知识点梳理5" class="headerlink" title="javascripts知识点梳理5"></a>javascripts知识点梳理5</h1><h2 id="JS面向对象"><a href="#JS面向对象" class="headerlink" title="JS面向对象"></a>JS面向对象</h2><p>ECMAScript 有两种开发模式：1.函数式(过程化)，2.面向对象(OOP)。面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript 没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。</p>
<p>js（如果没有作特殊说明，本文中的js仅包含ES5以内的内容）本身是没有class类型的，但是<u>每个函数都有一个prototype属性。prototype指向一个对象，</u><u>当函数作为构造函数时，prototype则起到类似class的作用。</u></p>
<p>面向过程：以前大部分的代码都是面向过程的</p>
<p>面向对象：使用内置对象功能，jQuery</p>
<h3 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h3><p><strong>封装：</strong>封装为对象(工具的封装操作)，需要调用即可，无需多次重写。 </p>
<p><strong>继承：</strong>子类可以继承父类的属性和方法 ，为了实现代码更好的复用</p>
<p><strong>多态（</strong>多状态）：让代码操作更加灵活</p>
<ol>
<li>重载：严格意义上说JS中没有重载的功能，不过我们可以通过判断函数的参数的不同来实现不同的功能来模拟重载。</li>
<li>重写：子类可以改写父类的属性和方法</li>
</ol>
<p>在这里我们可以理解为创造对象的几种模式：</p>
<h3 id="创造对象的几种模式"><a href="#创造对象的几种模式" class="headerlink" title="创造对象的几种模式"></a>创造对象的几种模式</h3><blockquote>
<p>单例模式，工厂模式，构造函数模式,原型模式等。 </p>
</blockquote>
<p><strong>单例模式</strong> </p>
<p>小王在一个小公司，就自己一个前端，所以他写js都是这样的 </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">var a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title">getNum</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>后来公司又招了个前端小明，于是变成他们2个一起写同一个js了。一天小王发现自己写的getNum方法出问题了，原来是小华写的js中也有个getNum的函数，代码合并后把他的覆盖掉了，于是便找小华理论去，经过一番妥协后，两人都把自己的代码改了改 </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    num:<span class="hljs-number">1</span>,<br>    getNum:<span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">var</span> xiaohua = &#123;<br>    num:<span class="hljs-number">2</span>,<br>    getNum: <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是我们所谓的单例模式(命名空间) </p>
<p><strong>单例模式的优劣</strong> </p>
<ol>
<li>使用单例模式，我们可以实现简单的模块化开发</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> utils = &#123;<br>    getCss:<span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//code</span><br>    &#125;,<br>    getByClass:<span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>         <span class="hljs-comment">//code</span><br>    &#125;,<br>    setCss:<span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//code</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以把自己写好的工具方法放到一个单独的js文件中，然后直接引入即可。</p>
<ol>
<li>避免了全局变量名的冲突<br>需要注意的是，我们在引入各个模块的时候，需要注意引入的顺序，引入顺序是按照各模块之间的相互依赖进行前后排列的；</li>
<li>缺点：</li>
<li><ul>
<li>单例模式只是一定程度上避免了变量名的冲突，但并不能彻底解决此问题，而且在不同的对象下，我们可能会有很多功能相同的代码，最终造成大量的冗余代码。</li>
</ul>
</li>
</ol>
<ul>
<li>单例模式让每个对象有了自己独立的命名空间，但是并不能批量生产的问题，每一个新的对象都要重新写一份一模一样的代码。</li>
</ul>
<p><strong>工厂模式</strong> </p>
<ol>
<li>工厂模式其实就是把需要一个个的编写的对象,放在一个函数中统一的进行创建，说白了就是普通函数的封装。</li>
<li>工厂模式总共3步骤：</li>
</ol>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span>）引进原材料 <span class="hljs-comment">--- 创建一个空对象</span><br><span class="hljs-number">2</span>）加工原材料 <span class="hljs-comment">--- 加工对象：给对象添加属性和方法；</span><br><span class="hljs-number">3</span>）输出产品 <span class="hljs-comment">--- 返回对象：return 对象；</span><br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CreatePerson</span>(<span class="hljs-params">name,age</span>)&#123;<br>        <span class="hljs-keyword">var</span> obj=&#123;&#125;;<span class="hljs-comment">//1.创建一个空对象</span><br>        <span class="hljs-comment">//2.加工对象</span><br>        obj.name=name;<br>        obj.age=age;<br>        obj.showName=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我的名字是：&#x27;</span>+this.name)<br>        &#125;;<br>        <span class="hljs-keyword">return</span> obj;<span class="hljs-comment">//3.输出对象；</span><br>&#125;<br><span class="hljs-keyword">var</span> person1 = CreatePerson(<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-number">23</span>)<br><span class="hljs-keyword">var</span> person2 = CreatePerson(<span class="hljs-string">&#x27;小华&#x27;</span>,<span class="hljs-number">23</span>)<br>person1.showName(); <span class="hljs-comment">//我的名字是：小明</span><br>person2.showName(); <span class="hljs-comment">//我的名字是：小华</span><br></code></pre></td></tr></table></figure>

<p>工厂模式的优缺点 </p>
<ul>
<li><ol>
<li>既然叫工厂模式，它就和我们周围的工厂一样，我们只需要把原材料放进去，就能得到我们需要的产品了。</li>
<li>工厂模式也解决了单例模式的批量生产的问题，避免了单例模式中的大量冗余代码，进行系统的封装，提高代码的重复利用率</li>
<li>不过工厂模式跟我们js内置类的调用方法不同</li>
</ol>
</li>
<li></li>
</ul>
<p> <strong>构造函数模式</strong> </p>
<ol>
<li>可以创建一个自定义的类，并且可以new出实例</li>
<li>构造函数做的就是类和实例打交道。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">//构造函数：首字母大写(约定俗成)；</span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">CreatePerson</span>(<span class="hljs-params">name,age</span>)&#123; <span class="hljs-comment">//创建一个自定义的类</span><br>     <span class="hljs-comment">//构造函数中的this，都是new出来的实例</span><br>     <span class="hljs-comment">//构造函数中存放的都是私有的属性和方法；</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">showName</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我的名字是：&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>     &#125;<br> &#125;<br><span class="hljs-comment">//实例1</span><br> <span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreatePerson</span>(<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-number">25</span>)<br><span class="hljs-comment">//实例2</span><br> <span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreatePerson</span>(<span class="hljs-string">&#x27;小华&#x27;</span>,<span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure>

<p>这里说一下工厂模式和构造函数模式的区别： </p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>. 在调用的时候不同：<br>工厂模式：调用的时候，只是普通函数的调用<span class="hljs-built_in">createPerson</span>();<br>构造函数模式：new <span class="hljs-built_in">CreatePerson</span>();<br><span class="hljs-number">2</span>. 在函数体内不同：<br>工厂模式有三步：<span class="hljs-number">1</span>）创建对象 <span class="hljs-number">2</span>）加工对象 <span class="hljs-number">3</span>）返回对象；<br>构造函数模式只有<span class="hljs-number">1</span>步： 只有加工对象； 因为系统默认会为其创建对象和返回对象；<br><span class="hljs-number">3</span>. 构造函数默认给我们返回了一个对象，如果我们非要自己手动返回的话：<br>    (<span class="hljs-number">1</span>)手动返回的是字符串类型：对以前实例上的属性和方法没有影响；<br>    (<span class="hljs-number">2</span>)手动返回的是引用数据类型:以前实例身上的属性和方法就被覆盖了；实例无法调用属性和方法；<br></code></pre></td></tr></table></figure>

<p>我们可以使用原型模式来解决每个实例中都有相同方法的函数的问题 </p>
<p><strong>原型模式</strong></p>
<p>我们把公有的方法放到函数的原型链上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CreatePerson</span>(<span class="hljs-params">name,age</span>)&#123; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-comment">// 我们把公有的方法放到函数的原型链上</span><br><span class="hljs-title class_">CreatePerson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我的名字是：&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;  <br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreatePerson</span>(<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-number">25</span>) <br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreatePerson</span>(<span class="hljs-string">&#x27;小华&#x27;</span>,<span class="hljs-number">24</span>)<br>person1.<span class="hljs-title function_">showName</span>() <span class="hljs-comment">//小明</span><br></code></pre></td></tr></table></figure>

<p><strong>原型模式的关键：</strong> </p>
<ol>
<li><p>1）每个函数数据类型（普通函数，类）上，都有一个属性，叫prototype。</p>
</li>
<li><p>2）prototype这个对象上，天生自带一个属性，叫constructor:指向当前这个类；</p>
</li>
<li><p>3）每个对象数据类型（普通对象，prototype，实例）上都有一个属性，</p>
</li>
<li><p>   叫做__proto__:指向当前实例所属类的原型</p>
</li>
</ol>
<h3 id="一．创建对象"><a href="#一．创建对象" class="headerlink" title="一．创建对象"></a>一．创建对象</h3><p>创建一个对象，然后给这个对象新建属性和方法。 </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">var <span class="hljs-built_in">box</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">Object</span>(); <span class="hljs-comment">//创建一个Object 对象</span><br>	<span class="hljs-built_in">box</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Lee&#x27;</span>; <span class="hljs-comment">//创建一个name 属性并赋值</span><br>	<span class="hljs-built_in">box</span>.<span class="hljs-property">age</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">//创建一个age 属性并赋值</span><br>	<span class="hljs-built_in">box</span>.<span class="hljs-property">run</span> = <span class="hljs-title function_">function</span> () &#123; <span class="hljs-comment">//创建一个run()方法并返回值</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">name</span> + <span class="hljs-variable">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&#x27;运行中...&#x27;</span>;<br>	&#125;;<br><span class="hljs-title function_">alert</span>(<span class="hljs-built_in">box</span>.<span class="hljs-property">run</span>()); <span class="hljs-comment">//输出属性和方法的值</span><br><br></code></pre></td></tr></table></figure>

<p>上面创建了一个对象，并且创建属性和方法，在run()方法里的this，就是代表box 对象本身。这种是JavaScript 创建对象最基本的方法，但有个缺点，想创建多个类似的对象，就会产生大量的代码。 为了解决多个类似对象声明的问题，我们可以使用一种叫做工厂模式的方法，这种方法就是为了解决实例化对象产生大量重复的问题。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">name, age</span>) &#123; <span class="hljs-comment">//集中实例化的函数</span><br>	<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>	obj.<span class="hljs-property">name</span> = name;<br>	obj.<span class="hljs-property">age</span> = age;<br>	obj.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&#x27;运行中...&#x27;</span>;<br>	&#125;;<br>	<span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-keyword">var</span> box1 = <span class="hljs-title function_">createObject</span>(<span class="hljs-string">&#x27;Lee&#x27;</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">//第一个实例</span><br><span class="hljs-keyword">var</span> box2 = <span class="hljs-title function_">createObject</span>(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">200</span>); <span class="hljs-comment">//第二个实例</span><br><span class="hljs-title function_">alert</span>(box1.<span class="hljs-title function_">run</span>());<br><span class="hljs-title function_">alert</span>(box2.<span class="hljs-title function_">run</span>()); <span class="hljs-comment">//保持独立</span><br><br></code></pre></td></tr></table></figure>

<p>工厂模式解决了重复实例化的问题，但是它有许多问题，创建不同对象其中属性和方法都会重复建立，消耗内存；还有函数识别问题等等。</p>
<h3 id="二．构造函数的方法"><a href="#二．构造函数的方法" class="headerlink" title="二．构造函数的方法"></a>二．构造函数的方法</h3><p>构造函数的方法有一些规范： 1）函数名和实例化构造名相同且大写，(PS：非强制，但这么写有助于区分构造函数和 普通函数)； 2）通过构造函数创建对象，必须使用new 运算符。 </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Box</span><span class="hljs-params">(name, age)</span> &#123; <span class="hljs-comment">//构造函数模式</span><br>	<span class="hljs-keyword">this</span>.name = name;<br>	<span class="hljs-keyword">this</span>.age = age;<br>	<span class="hljs-keyword">this</span>.run = <span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name + <span class="hljs-keyword">this</span>.age + <span class="hljs-string">&#x27;运行中...&#x27;</span>;<br>	&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> box1 = <span class="hljs-keyword">new</span> Box(<span class="hljs-string">&#x27;Lee&#x27;</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">//new Box()即可</span><br><span class="hljs-keyword">var</span> box2 = <span class="hljs-keyword">new</span> Box(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">200</span>);<br>alert(box1.run());<br>alert(box1 <span class="hljs-keyword">instanceof</span> Box); <span class="hljs-comment">//很清晰的识别他从属于Box</span><br><br></code></pre></td></tr></table></figure>

<p> 构造函数可以创建对象执行的过程： 1）当使用了构造函数，并且new 构造函数()，那么就后台执行了new Object()； 2）将构造函数的作用域给新对象，(即new Object()创建出的对象)，而函数体内的this 就 代表new Object()出来的对象。 3）执行构造函数内的代码； 4）返回新对象(后台直接返回)。 </p>
<p>注：</p>
<p>1）构造函数和普通函数的唯一区别，就是他们调用的方式不同。只不过，构造函数也是函数，必须用new 运算符来调用，否则就是普通函数。</p>
<p>2）this就是代表当前作用域对象的引用。如果在全局范围this 就代表window 对象，如果在构造函数体内，就代表当前的构造函数所声明的对象。</p>
<p>这种方法解决了函数识别问题，但消耗内存问题没有解决。同时又带来了一个新的问题，全局中的this 在对象调用的时候是Box 本身，而当作普通函数调用的时候，this 又代表window。即this作用域的问题。</p>
<h3 id="三-原型"><a href="#三-原型" class="headerlink" title="三.原型"></a>三.原型</h3><p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个对象，它的用途是包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解：prototype 通过调用构造函数而创建的那个对象的原型对象。使用原型的好处可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Box</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">//声明一个构造函数</span><br><span class="hljs-title class_">Box</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Lee&#x27;</span>; <span class="hljs-comment">//在原型里添加属性</span><br><span class="hljs-title class_">Box</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">100</span>;<br><span class="hljs-title class_">Box</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//在原型里添加方法</span><br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&#x27;运行中...&#x27;</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>所以，它解决了消耗内存问题。当然它也可以解决this作用域等问题。 </p>
<p>我们经常把属性（一些在实例化对象时属性值改变的），定义在构造函数内；把公用的方法添加在原型上面，也就是混合方式构造对象（构造方法+原型方式）： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)&#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br> &#125;;<br> person.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>; <br> &#125;<br> <span class="hljs-keyword">var</span> zjh = <span class="hljs-keyword">new</span> <span class="hljs-title function_">person</span>(‘zhangjiahao’);<br> zjh.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">//zhangjiahao</span><br><br></code></pre></td></tr></table></figure>



<h2 id="内置对象添加方法"><a href="#内置对象添加方法" class="headerlink" title="内置对象添加方法"></a>内置对象添加方法</h2><p>直接给内置构造函数原型添加即可</p>
<p>例如:Array.prototype.getSum &#x3D; function () {}</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>表示将代码根据功能分为不同区域<br>使用立即执行函数对不同功能的代码进行包裹<br>使用一个js库requirejs<br>用于解决引入顺序问题</p>
<p>在html页面中引入require文件,并设置data-main属性声明入口模块路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> =<span class="hljs-string">&quot;require.js&quot;</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">在入口模块中声明依赖关系,参数<span class="hljs-number">1</span>为地址,参数<span class="hljs-number">2</span>为函数<br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;js/game&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">Game</span>)&#123;<br>......<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">在模块中需要被其他模块调用的进行返回值设置<br>define([<span class="hljs-string">&#x27;js/food&#x27;</span> , <span class="hljs-string">&#x27;js/snake&#x27;</span>] , <span class="hljs-keyword">function</span>(<span class="hljs-params">Food , Snake</span>)&#123;<br>......<br><span class="hljs-keyword">return</span> Game;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="高级技巧-判断是数组还是对象"><a href="#高级技巧-判断是数组还是对象" class="headerlink" title="高级技巧_判断是数组还是对象"></a>高级技巧_判断是数组还是对象</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs delphi">  <span class="hljs-comment">// console.log(a.consturctor);</span><br>    <span class="hljs-comment">// function fn()&#123;</span><br>        <span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">var</span> c = <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">            name:&#x27;zs&#x27;,</span><br><span class="hljs-comment">            age:18</span><br><span class="hljs-comment">        &#125;</span><br>        <span class="hljs-keyword">var</span> b = c.<span class="hljs-keyword">constructor</span><br>  <br>    console.log(b);<br><br><br> <span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> b = a.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span> ? [] :<span class="hljs-comment">&#123;&#125;</span>;<br>console.log(b);<br><br>因为  数组  和   对象都属于函数  函数就有原型对象<br>利用原型对象里的<span class="hljs-function"><span class="hljs-keyword">constructor</span>  属性指向</span><br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/javascript/" class="category-chain-item">javascript</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/javascript/" class="print-no-link">#javascript</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>javascripts知识点梳理5</div>
      <div>http://luckyangyang.github.io/2019/04/02/javascripts知识点梳理5/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>幸福来敲门</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>April 2, 2019</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/05/10/HTML5_API/" title="HTML5_API">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTML5_API</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/03/26/javascripts%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%864/" title="javascripts知识点梳理4">
                        <span class="hidden-mobile">javascripts知识点梳理4</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Luck</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>幸福来敲门</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
  <!-- 动态背景 -->
<script color="0,0,0" opacity='0.7' zIndex="-2" count="200" type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
